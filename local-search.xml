<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MobSF框架源码分析</title>
    <link href="/2022/09/09/MobSF%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2022/09/09/MobSF%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="MobSF动态分析框架"><a href="#MobSF动态分析框架" class="headerlink" title="MobSF动态分析框架"></a>MobSF动态分析框架</h1><h2 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h2><h3 id="项目入口：MobSF基于Django开发，入口在-MobSF-urls-py"><a href="#项目入口：MobSF基于Django开发，入口在-MobSF-urls-py" class="headerlink" title="项目入口：MobSF基于Django开发，入口在/MobSF/urls.py"></a>项目入口：MobSF基于Django开发，入口在<code>/MobSF/urls.py</code></h3><ul><li><p>一般功能URL</p><p>一般功能包括：上传APP、下载报告、信息说明、搜索、删除等</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-29%2016.26.11.png" alt="截屏2022-08-29 16.26.11" style="zoom:40%;" /></li><li><p>静态分析对应的URL</p><p>静态分析分为：Android应用、ios应用、Windows应用、PDF和应用hash比较查重</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-29%2016.27.06.png" alt="截屏2022-08-29 16.27.06" style="zoom:40%;" /></li><li><p>动态分析对应的URL</p><p>只支持Android应用的动态分析，包括Android设备操作、动态测试、frida框架和动态分析报告生成</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-29%2016.44.07.png" alt="截屏2022-08-29 16.44.07" style="zoom:40%;" /></li><li><p>封装的api接口</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-29%2016.45.09.png" alt="截屏2022-08-29 16.45.09" style="zoom:40%;" /></li></ul><h3 id="一般功能模块分析："><a href="#一般功能模块分析：" class="headerlink" title="一般功能模块分析："></a>一般功能模块分析：</h3><ul><li><p>上传：</p><p>定位一般功能入口中的上传模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re_path(<span class="hljs-string">r&#x27;^upload/$&#x27;</span>, home.Upload.as_view),<br></code></pre></td></tr></table></figure><p>跟进到<code>/MobSF/views/home.py</code>中的<code>upload_html()</code>函数，上传只支持<code>POST</code>方法：</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-29%2017.09.12.png" alt="截屏2022-08-29 17.09.12" style="zoom:40%;" /><p>随后会对上传的的文件分类，根据不同类型做对应的扫描操作：</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-29%2017.11.20.png" alt="截屏2022-08-29 17.11.20" style="zoom:40%;" /></li><li><p>扫描：跟进到<code>/MobSF/views/scanning.py</code>中的<code>Scanning</code>类，发现扫描分为5类，分别是：APK、XAPK、APK、ZIP、IPA包和APPX包。然后，对apk扫描函数进一步分析：</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-29%2017.22.12.png" alt="截屏2022-08-29 17.22.12" style="zoom:50%;" /><p>首先计算出上传文件的md5值，然后将扫描任务添加的最近扫描。</p></li></ul><h3 id="静态分析模块"><a href="#静态分析模块" class="headerlink" title="静态分析模块"></a>静态分析模块</h3><p>静态分析模块在目录<code>/StaticAnalyzer/views/</code>下，我们以apk分析为例</p><ul><li><p>静态分析开始后，首先解压上传的apk包，若解压失败则报错并退出</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-30%2010.11.12.png" alt="截屏2022-08-30 10.11.12" style="zoom:40%;" /></li><li><p>然后正式进入静态分析，先是对<code>AndroidManifest.xml</code>的分析：</p><ol><li><p>使用apktool反编译apk包，获取XML文件</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-30%2010.24.13.png" alt="截屏2022-08-30 10.24.13" style="zoom:40%;" /><p>然后，提取XML文件中的参数信息，包括：<code>application、user-permission、manifest、activity、service、provider</code>等参数信息。</p></li><li><p>权限分析</p><p>将权限的安全等级分为4级</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-30%2010.42.13.png" alt="截屏2022-08-30 10.42.13" style="zoom:40%;" /></li><li><p>配置安全分析</p></li></ol></li><li><p>获取app名和图标，从AndroidManifest.xml中的<code>&lt;application&gt;</code>标签下的<code>android:lable</code>属性值得到app名，或者读取<code>/res/values/strings.xml</code>中的属性值</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-30%2012.10.57.png" alt="截屏2022-08-30 12.10.57" style="zoom:40%;" /><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-30%2011.45.19.png" alt="截屏2022-08-30 11.45.19" style="zoom:40%;" /><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-30%2011.54.18.png" alt="截屏2022-08-30 11.54.18" style="zoom:40%;" /></li><li><p>设置manifest链接</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-30%2012.12.02.png" alt="截屏2022-08-30 12.12.02" style="zoom:40%;" /></li><li><p>manifest文件信息提取和安全分析，前面有提到，这里不再重复</p></li><li><p>get_app_details</p><p>是获取应用商店中app的相关数据，包括：app名称、评分、价格、下载URL等</p></li><li><p>elf_analysis&#x2F;res_analysis</p><p>跟进到<code>/StaticAnalyzer/views/android/binary_analysis.py</code>文件中，对资源文件、so文件和字符串等做分析。</p></li><li><p>cert_info</p><p>证书分析模块，跟进到<code>/StaticAnalyzer/views/android/cert_analysis.py</code>，有两个函数：</p><p><strong>get_hardcoded_cert_keystore()：</strong></p><p>查找证书文件或密钥文件并返回，包括cer、pem、cert、crt、pub、key、pfx、p12等证书，jks、bks等密钥库。</p><p><strong>cert_info()：</strong></p><p>获取证书信息进行分析，包括debug签名、SHA1签名、md5签名、正常签名</p></li><li><p>apkid_analysis：<code>/MalwareAnalyzer/views/apkid.py</code></p><p>从apkid的python库中导入相关库，然后开始分析</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-30%2014.11.17.png" alt="截屏2022-08-30 14.11.17" style="zoom:40%;" /></li><li><p>Trackers：<code>/MalwareAnalyzer/views/Trackers.py</code></p><p><code>_update_tracker_db()</code>：更新数据库</p><p><code>_compile_signatures()</code>：编译与签名相关的正则表达式</p><p><code>load_tarckers_signatures()</code>：从官方数据库加载跟踪器签名</p><p><code>get_embedded_classes()</code>：通过backsmali获取DEX文件中的java类列表</p><p><code>detect_trackers_in_list()</code>：根据java类列表，检测其中的跟踪器，返回跟踪器列表</p><p><code>detect_trackers()</code>：检测嵌入的跟踪器</p><p><code>get_trackers()</code>：获取跟踪器</p></li><li><p>apk_2_java&#x2F;dex_2_smali：<code>/StaticAnalyzer/views/android/converter.py</code></p><p>dex_2_smali：通过backsmali将dex反编译为smali代码</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-30%2014.43.05.png" alt="截屏2022-08-30 14.43.05" style="zoom:40%;" /><p>apk_2_java：通过jadx反编译apk为java代码</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-30%2014.59.25.png" alt="截屏2022-08-30 14.59.25" style="zoom:40%;" /></li><li><p>code_analysis</p><p>进行代码和api的规则匹配，提取URL和e-mail信息</p><p>代码正则匹配和规则：</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-09-09%2015.59.47.png" alt="截屏2022-09-09 15.59.47" style="zoom:40%;" /><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-09-09%2016.01.20.png" alt="截屏2022-09-09 16.01.20" style="zoom:40%;" /><p>api正则匹配和规则：</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-09-09%2016.02.07.png" alt="截屏2022-09-09 16.02.07" style="zoom:40%;" /><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-09-09%2016.02.30.png" alt="截屏2022-09-09 16.02.30" style="zoom:40%;" /><p>URL匹配：</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-09-09%2015.33.53.png" alt="截屏2022-09-09 15.33.53" style="zoom:40%;" /><p>email匹配：</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-09-09%2015.34.16.png" alt="截屏2022-09-09 15.34.16" style="zoom:40%;" /></li><li><p>quark分析</p><p>利用恶意apk分析框架quark对apk进行分析</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-30%2015.36.17.png" alt="截屏2022-08-30 15.36.17" style="zoom:40%;" /></li><li><p>提取字符串信息</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-30%2015.34.14.png" alt="截屏2022-08-30 15.34.14" style="zoom:40%;" /></li><li><p>数据库相关</p><p>数据准备：firebase数据库检测、提取域名和恶意软件检测，复制app图标</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-30%2015.45.34.png" alt="截屏2022-08-30 15.45.34" style="zoom:40%;" /><p>数据库交互（入库，更新）</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-30%2015.48.34.png" alt="截屏2022-08-30 15.48.34" style="zoom:40%;" /></li><li><p>VT信息：从VirusTotal获取样本报告信息</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-30%2015.56.09.png" alt="截屏2022-08-30 15.56.09" style="zoom:40%;" /></li></ul><h3 id="动态分析模块"><a href="#动态分析模块" class="headerlink" title="动态分析模块"></a>动态分析模块</h3><p>动态分析模块在<code>/DynamicAnalyzer/views/android/</code>目录下</p><ul><li><p>首先还是在<code>/MobSF/urls.py</code>文件中，找到动态分析模块</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-31%2011.40.50.png" alt="截屏2022-08-31 11.40.50" style="zoom:40%;" /></li><li><p>然后跟进到<code>dynamic_analysis()</code>函数</p><p>该函数为安卓动态分析的入口点，先会检测模拟器是否运行：</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-31%2011.49.23.png" alt="截屏2022-08-31 11.49.23" style="zoom:40%;" /><p>若模拟器正常运行并被检测到，则获取设备信息。然后会设置代理ip，通过<code>get_proxy_ip()</code>来获取当前网络ip，并根据它来设置代理ip</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-31%2012.01.40.png" alt="截屏2022-08-31 12.01.40" style="zoom:40%;" /><p>若模拟器未启动或没检测到，则通过<code>print_n_send_error_response()</code>报错</p></li><li><p>然后，跟进到函数<code>dynamic_analyzer()</code>，在获取到设备信息后，通过<code>Evironment.py</code>模块设置动态分析环境：</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-31%2012.20.12.png" alt="截屏2022-08-31 12.20.12" style="zoom:40%;" /></li><li><p>跟进到<code>Enronmen.py</code>中，通过下面一系列函数来设置动态分析环境；</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_connect_error</span>() <span class="hljs-comment"># 检查是否连接模拟器失败</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_subprocess_verify_output</span>() <span class="hljs-comment"># 运行子线程，确认模拟器执行</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">connect_n_mount</span>() <span class="hljs-comment"># 重启adb服务，并尝试adb连接设备</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_package_installed</span>() <span class="hljs-comment"># 检查包是否安装</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">install_apk</span>() <span class="hljs-comment"># 安装要分析的apk，并检测是否安装成功</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">adb_command</span>() <span class="hljs-comment"># 将所有要执行的命令，包装成可以执行的命令，然后执行</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dz_cleanup</span>() <span class="hljs-comment"># 清除之前的动态分析记录</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">configure_proxy</span>() <span class="hljs-comment"># 设置代理，先杀死请求，再在代理模式下开启Httptools</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">install_mobsf_ca</span>() <span class="hljs-comment"># 安裝或刪除MobSF的根证书（ROOT CA）</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">set_global_proxy</span>() <span class="hljs-comment"># 设置全局代理，只支持Android 4.4及以上系統，对于Android 4.4以前的系统版本，会将代理设置为：127.0.0.1:1337</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">unset_global_proxy</span>() <span class="hljs-comment"># 取消全局代理设置</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">enable_adb_reverse_tcp</span>() <span class="hljs-comment"># 开启adb反向TCP代理，只支持Android 5.0以上的系統</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">start_clipmon</span>() <span class="hljs-comment"># 开启剪切板监控</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_screen_res</span>() <span class="hljs-comment"># 获取当前设备的屏幕分辨率</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">screen_shot</span>() <span class="hljs-comment"># 截屏，并保存为/data/local/screen.png。</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">screen_stream</span>() <span class="hljs-comment"># 分析屏幕流</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">android_component</span>() <span class="hljs-comment"># 获取APK组件，包括Activity、Receiver、Provider、Service、Library等</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_environment</span>() <span class="hljs-comment"># 识别分析环境配置</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_android_version</span>() <span class="hljs-comment"># 获取当前Android版本</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_android_arch</span>() <span class="hljs-comment"># 获取Android体系结构</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_android_sdk</span>() <span class="hljs-comment"># 获取sdk版本信息</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_device_packages</span>() <span class="hljs-comment"># 从设备获取所有包</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_apk</span>() <span class="hljs-comment"># 从设备下载apk文件</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">system_check</span>() <span class="hljs-comment"># 检查系统是否为可写入状态</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">launch_n_capture</span>() <span class="hljs-comment"># 启动和捕获Activity，通过截屏实现</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_app</span>() <span class="hljs-comment"># 以包名称启动app</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_mobsfyied</span>() <span class="hljs-comment"># 获取Android的MobSfyied实例，读取Xposed或Frida文件并输出</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mobsfy_init</span>(<span class="hljs-params">self</span>) <span class="hljs-comment"># 初始化设置MobSF代理，安装xposed或frida</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mobsf_agents_setup</span>(<span class="hljs-params">self, agent</span>): <span class="hljs-comment"># 安装MobSF根证书，设置代理</span><br>        version = self.get_android_version()<br>        logger.info(<span class="hljs-string">&#x27;Android Version identified as %s&#x27;</span>, version)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">if</span> version &lt; <span class="hljs-number">5</span>: <span class="hljs-comment"># android5.0以前版本，安装xposed</span><br>                self.xposed_setup(version)<br>                self.mobsf_agents_setup(<span class="hljs-string">&#x27;xposed&#x27;</span>)<br>            <span class="hljs-keyword">else</span>: <span class="hljs-comment"># android5.0以上版本，安装frida</span><br>                self.frida_setup()<br>                self.mobsf_agents_setup(<span class="hljs-string">&#x27;frida&#x27;</span>)<br>            logger.info(<span class="hljs-string">&#x27;MobSFying Completed!&#x27;</span>)<br>            <span class="hljs-keyword">return</span> version<br>        <span class="hljs-keyword">except</span> Exception:<br>            logger.exception(<span class="hljs-string">&#x27;Failed to MobSFy Android Instance&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">xposed_setup</span>(<span class="hljs-params">self, android_version</span>) <span class="hljs-comment"># 安装xposed框架</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">frida_setup</span>(<span class="hljs-params">self</span>) <span class="hljs-comment"># 安装frida框架</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_frida_server</span>(<span class="hljs-params">self</span>) <span class="hljs-comment"># 运行frida</span><br><br></code></pre></td></tr></table></figure><ul><li><p>继续往下分析<code>dynamic_analyzer.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs python">version = env.get_android_version() <span class="hljs-comment"># 获取Android版本</span><br>        logger.info(<span class="hljs-string">&#x27;Android Version identified as %s&#x27;</span>, version)<br>        xposed_first_run = <span class="hljs-literal">False</span><br>        <span class="hljs-comment"># 根据系统版本获取Mobfyied实例，若获取失败，</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> env.is_mobsfyied(version):<br>            msg = (<span class="hljs-string">&#x27;This Android instance is not MobSFyed/Outdated.\n&#x27;</span><br>                   <span class="hljs-string">&#x27;MobSFying the android runtime environment&#x27;</span>)<br>            logger.warning(msg)<br>            <span class="hljs-comment"># 设置MobSF代理，若失败，</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> env.mobsfy_init():<br>                <span class="hljs-keyword">return</span> print_n_send_error_response(<br>                    request,<br>                    <span class="hljs-string">&#x27;Failed to MobSFy the instance&#x27;</span>,<br>                    api)<br>            <span class="hljs-keyword">if</span> version &lt; <span class="hljs-number">5</span>:<br>                xposed_first_run = <span class="hljs-literal">True</span><br>        <span class="hljs-comment"># 第一次运行xposed框架，重启所有模块</span><br>        <span class="hljs-keyword">if</span> xposed_first_run:<br>            msg = (<span class="hljs-string">&#x27;Have you MobSFyed the instance before&#x27;</span><br>                   <span class="hljs-string">&#x27; attempting Dynamic Analysis?&#x27;</span><br>                   <span class="hljs-string">&#x27; Install Framework for Xposed.&#x27;</span><br>                   <span class="hljs-string">&#x27; Restart the device and enable&#x27;</span><br>                   <span class="hljs-string">&#x27; all Xposed modules. And finally&#x27;</span><br>                   <span class="hljs-string">&#x27; restart the device once again.&#x27;</span>)<br>            <span class="hljs-keyword">return</span> print_n_send_error_response(request, msg, api)<br>        <span class="hljs-comment"># 清除之前的分析记录</span><br>        env.dz_cleanup(checksum)<br>        <span class="hljs-comment"># 设置web代理</span><br>        env.configure_proxy(package, request)<br>        <span class="hljs-comment"># 开启adb反向tcp代理，只支持Android5.0以上</span><br>        env.enable_adb_reverse_tcp(version)<br>        <span class="hljs-comment"># 开启全局代理，只支持Android4.4以上</span><br>        env.set_global_proxy(version)<br>        <span class="hljs-comment"># 开启剪贴板监控</span><br>        env.start_clipmon()<br>        <span class="hljs-comment"># 获取当前设备屏幕分辨率</span><br>        screen_width, screen_height = env.get_screen_res()<br>        <span class="hljs-keyword">if</span> install == <span class="hljs-string">&#x27;1&#x27;</span>:<br>            <span class="hljs-comment"># 安装apk</span><br>            apk_path = Path(settings.UPLD_DIR) / checksum / <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;checksum&#125;</span>.apk&#x27;</span><br>            status, output = env.install_apk(<br>                apk_path.as_posix(),<br>                package,<br>                reinstall)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> status:<br>                <span class="hljs-comment"># 重置代理</span><br>                env.unset_global_proxy()<br>                msg = (<span class="hljs-string">f&#x27;This APK cannot be installed. Is this APK &#x27;</span><br>                       <span class="hljs-string">f&#x27;compatible the Android VM/Emulator?\n<span class="hljs-subst">&#123;output&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">return</span> print_n_send_error_response(<br>                    request,<br>                    msg,<br>                    api)<br>        logger.info(<span class="hljs-string">&#x27;Testing Environment is Ready!&#x27;</span>)<br>        context = &#123;<span class="hljs-string">&#x27;screen_width&#x27;</span>: screen_width,<br>                   <span class="hljs-string">&#x27;screen_height&#x27;</span>: screen_height,<br>                   <span class="hljs-string">&#x27;package&#x27;</span>: package,<br>                   <span class="hljs-string">&#x27;hash&#x27;</span>: checksum,<br>                   <span class="hljs-string">&#x27;android_version&#x27;</span>: version,<br>                   <span class="hljs-string">&#x27;version&#x27;</span>: settings.MOBSF_VER,<br>                   <span class="hljs-string">&#x27;activities&#x27;</span>: activities,<br>                   <span class="hljs-string">&#x27;exported_activities&#x27;</span>: exported_activities,<br>                   <span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;Dynamic Analyzer&#x27;</span>&#125;<br>        template = <span class="hljs-string">&#x27;dynamic_analysis/android/dynamic_analyzer.html&#x27;</span><br>        <span class="hljs-keyword">if</span> api:<br>            <span class="hljs-keyword">return</span> context<br>        <span class="hljs-comment"># 通过HttpResponse返回数据</span><br>        <span class="hljs-keyword">return</span> render(request, template, context)<br>    <span class="hljs-keyword">except</span> Exception:<br>        logger.exception(<span class="hljs-string">&#x27;Dynamic Analyzer&#x27;</span>)<br>        <span class="hljs-keyword">return</span> print_n_send_error_response(<br>            request,<br>            <span class="hljs-string">&#x27;Dynamic Analysis Failed.&#x27;</span>,<br>          api)<br></code></pre></td></tr></table></figure></li><li><p><code>httptools_start()</code>函数：</p><p>该函数线调用<code>stop_httptools()</code>杀死请求，然后在代理模式下开启Httptools</p></li><li><p><code>logcat()</code>函数：</p><p>启动logcat，获取日志信息</p></li><li><p>跟进<code>operations.py</code>文件，主要是动态分析相关操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">json_response</span>() <span class="hljs-comment"># 返回JSON响应</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_attack_pattern</span>() <span class="hljs-comment"># 通过正则表达式验证攻击</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">strict_package_check</span>() <span class="hljs-comment"># 通过正则表达式校验包名称</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_path_traversal</span>() <span class="hljs-comment"># 检查路径遍历</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_md5</span>() <span class="hljs-comment"># 通过正则表达式检查是否是有效的MD5</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">invalid_params</span>() <span class="hljs-comment"># 检查无效参数响应</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mobsfy</span>() <span class="hljs-comment"># 通过POST方法配置实例以进行动态分析</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_adb</span>() <span class="hljs-comment"># 通过POST方法执行adb命令</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_component</span>() <span class="hljs-comment"># 通过POST方法获取Android组件</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">take_screenshot</span>() <span class="hljs-comment"># 通过POST方法截屏</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">screen_cast</span>() <span class="hljs-comment"># 通过POST方法投屏</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">touch</span>() <span class="hljs-comment"># 通过POST方法发送触摸事件</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mobsf_ca</span>() <span class="hljs-comment"># 通过POST方法安装或删除MobSF代理的根证书（ROOT CA）</span><br></code></pre></td></tr></table></figure></li><li><p>跟进<code>analysis.py</code>文件</p><p>首先，收集日志数据并遍历筛选：</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-31%2015.34.45.png" alt="截屏2022-08-31 15.34.45" style="zoom:40%;" /><p>通过正则表达式收集URL数据，检查恶意URL，并匹配是否出现在恶意软件列表中：</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-31%2015.25.34.png" alt="截屏2022-08-31 15.25.34" style="zoom:40%;" /><p>通过正则表达式提取e-mail地址，并汇总提取到的信息：</p><img src="https://bob-markdown.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-31%2015.28.50.png" alt="截屏2022-08-31 15.28.50" style="zoom:40%;" /></li><li><p>动态分析还有以下功能函数，简单介绍一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_screenshots</span>() <span class="hljs-comment"># 获取屏幕截图</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_tls_logs</span>() <span class="hljs-comment"># 获取TLS/SSL测试日志</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_log_data</span>() <span class="hljs-comment"># 对日志数据进行分析，得到web数据、日志数据、域名数据、API数据、Frida数据，并返回。</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_app_files</span>() <span class="hljs-comment"># 从设备获取APP文件，包括提取设备数据，对设备中的数据做静态分析等</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_download</span>（） <span class="hljs-comment"># 生成文件下载，生成文件下载后，会删除现有数据，然后复制新数据</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dynamic Analysis</tag>
      
      <tag>Framework</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hook框架-xposed和frida</title>
    <link href="/2022/09/02/hook%E6%A1%86%E6%9E%B6-xposed%E5%92%8Cfrida/"/>
    <url>/2022/09/02/hook%E6%A1%86%E6%9E%B6-xposed%E5%92%8Cfrida/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Xposed"><a href="#1-Xposed" class="headerlink" title="1. Xposed"></a>1. Xposed</h2><ul><li><p>xposed框架支持Java层的Dalvik Hook和ART Hook，但不支持Native层Hook</p></li><li><p>xposed原理：Android所有的用户进程都是通过Zygote孵化出来的，而Zygote的执行程序是app_process。我们安装Xposed后，xposed会将app_process替换，并替换对应的虚拟机，这样Zygote孵化器就变成了Xposed孵化器。</p></li><li><p>xposed hook原理：由于修改了ART&#x2F;Davilk虚拟机，将需要hook的函数注册为Native层函数。当执行到这一函数是虚拟机会优先执行Native层函数，然后再去执行Java层函数，这样完成函数的hook</p></li><li><p>使用：一般是通过编写插件来hook对应的Java方法</p><p>通过<code>XC_MethodHook</code>接口的<code>beforeHookedMethod()</code>和<code>afterHookedMethod()</code>方法，分别在要Hook的方法之前或者之后添加我们新编写的处理代码。也可以使用<code>XC_MethodReplacement</code>直接替换要Hook的方法的实现方式。</p></li><li><p>场景：开启日志调试输出、编写APK插件、SSL Pinning绕过</p></li></ul><h2 id="2-Frida"><a href="#2-Frida" class="headerlink" title="2. Frida"></a>2. Frida</h2><ul><li>frida一般使用：<ol><li>在PC端安装Frida</li><li>在Android设备端安装frida-server，并启动</li></ol></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">adb push frida-server /data/local/tmp</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">adb shell <span class="hljs-string">&quot;chmod 755 /data/local/tmp/frida-server&quot;</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>执行注入</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">frida -U --no-pause -f com.droider.crakme0201</span><br></code></pre></td></tr></table></figure><ul><li><p>Hook方法：</p><ul><li><p><strong>Java层注入式Hook举例：</strong></p><ol><li>先使用Java.use()获取MainActivity类，</li><li>再修改其checkSN函数的implementation属性</li><li>hook的JavaScript脚本如下：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">setImmediate</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[*]Starting script&quot;</span>);<br>    <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> clz = <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;com.droider.crackme0201.MainActivity&quot;</span>);<br>        <span class="hljs-comment">// 修改checkSN的implementation属性，无论输入何值都返回true</span><br>        clz.<span class="hljs-property">checkSN</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">s1, s2</span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[*]checkSN() called&quot;</span>);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[*]s1: &quot;</span> + s1);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[*]s2: &quot;</span> + s2);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[*] onClick handler modified&quot;</span>);<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>修改了验证码检查函数方法，使无论输入何值，都注册成功</p><ol start="4"><li>shell注入挂hook</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">frida -U -l crackme0201Hooker.js com.droider.crackme0201</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Native层跟踪式Hook</strong></p><ol><li><p>利用Frida提供的<code>frida-trace</code>来hook目标函数</p></li><li><p>执行以下命令，来hook示例程序中的<code>open()</code>函数，</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">frida-trace -U -i open com.android.phone</span><br></code></pre></td></tr></table></figure><ol start="3"><li>在<code>./_handlers_/libc.so</code>目录下生成一个<code>open.js</code>文件，通过修改这个js脚本，可以获取更多信息</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">log, args, state</span>)&#123;<br><span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;open(&quot;</span> + <span class="hljs-string">&quot;pathname=&quot;</span> + <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">readUtf8String</span>(args[<span class="hljs-number">0</span>])+ <span class="hljs-string">&quot;, flags=&quot;</span> + args[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;)&quot;</span>);<br>&#125;,<br></code></pre></td></tr></table></figure><ol start="4"><li>P.S. <code>frida-trace</code>命令的一般参数使用有以下：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">frida-trace -U -m <span class="hljs-string">&quot;Object-C Name&quot;</span>         // 对Object-C的方法进行hook</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">frida-trace -U -i <span class="hljs-string">&quot;C-Function Name&quot;</span>       // 对目标函数hook</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">frida-trace -U -i <span class="hljs-string">&quot;open&quot;</span> -f com.android.media       // USB链接自动启动进程，hook目标程序中所有包含“open”关键字的函数</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>frida进阶使用：</p><ul><li><p>RPC远程调用</p><p><code>python层</code>与<code>js层</code>交互，示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> frida<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">on_message</span>(<span class="hljs-params">message, data</span>):<br>    <span class="hljs-keyword">if</span> message[<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;send&#x27;</span>:<br>        <span class="hljs-built_in">print</span>(message[<span class="hljs-string">&#x27;payload&#x27;</span>])<br>    <span class="hljs-keyword">elif</span> message[<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;error&#x27;</span>:<br>        <span class="hljs-built_in">print</span>(message[<span class="hljs-string">&#x27;stack&#x27;</span>])<br><br>// attach目标进程<br>session = frida.get_usb_device().attach(<span class="hljs-string">&#x27;android.process.media&#x27;</span>)<br><br>// js代码<br>source = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    rpc.exports = &#123;              // 通过rpc.exports关键字定义需要导出的两个函数</span><br><span class="hljs-string">    add: function (a, b) &#123;</span><br><span class="hljs-string">        return a + b;</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    sub: function (a, b) &#123;</span><br><span class="hljs-string">        return new Promise(function (resolve) &#123;</span><br><span class="hljs-string">        setTimeout(function () &#123;</span><br><span class="hljs-string">            resolve(a - b);</span><br><span class="hljs-string">        &#125;, 100);</span><br><span class="hljs-string">        &#125;);</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    &#125;;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>// 创建脚本并注入进程，加载js脚本<br>script = session.create_script(source)<br>script.on(<span class="hljs-string">&#x27;message&#x27;</span>, on_message)<br>script.load()<br><span class="hljs-built_in">print</span>(script.exports.add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-built_in">print</span>(script.exports.sub(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>))<br>session.detach()<br></code></pre></td></tr></table></figure></li><li><p>Process对象</p><ol><li><p><code>Process.id</code>：返回附加目标进程的<code>PID</code></p></li><li><p><code>Process.isDebuggerAttached()</code>：检测当前是否对目标程序已经附加</p></li><li><p><code>Process.enumerateModules()</code>：枚举当前加载的<code>so</code>模块，返回<code>Modules</code>对象的数组。</p></li><li><p><code>Process.enumerateThreads()</code>：枚举当前所有的线程，返回包含以下属性的对象数组：</p><table><thead><tr><th align="center">属性</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">id</td><td align="left">线程id</td></tr><tr><td align="center">state</td><td align="left">当前运行状态有running, stopped, waiting, uninterruptible or halted</td></tr><tr><td align="center">context</td><td align="left">带有键pc和sp的对象，它们是分别为ia32&#x2F;x64&#x2F;arm指定EIP&#x2F;RIP&#x2F;PC和ESP&#x2F;RSP&#x2F;SP的NativePointer对象。也可以使用其他处理器特定的密钥，例如eax、rax、r0、x0等。</td></tr></tbody></table></li><li><p><code>Process.getCurrentThreadId()</code>：获取此线程的操作系统特定 <code>ID</code> 作为数字</p></li></ol></li><li><p>Module对象</p><ol><li><p>属性：</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>name</td><td>模块名称</td></tr><tr><td>base</td><td>模块地址</td></tr><tr><td>size</td><td>大小</td></tr><tr><td>path</td><td>完整文件路径</td></tr></tbody></table></li><li><p>几种API方法举例：</p><p><strong>Module.load()</strong></p><p>主要用于加载指定<code>so</code>文件，返回一个<code>Module</code>对象，示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">frida_Module</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>         <span class="hljs-comment">//参数为so的名称 返回一个Module对象</span><br>         <span class="hljs-keyword">const</span> hooks = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;libhello.so&#x27;</span>);<br>         <span class="hljs-comment">//输出</span><br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;模块名称:&quot;</span>,hooks.<span class="hljs-property">name</span>);<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;模块地址:&quot;</span>,hooks.<span class="hljs-property">base</span>);<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;大小:&quot;</span>,hooks.<span class="hljs-property">size</span>);<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文件系统路径&quot;</span>,hooks.<span class="hljs-property">path</span>);<br>    &#125;);<br>&#125;<br><span class="hljs-title function_">setImmediate</span>(frida_Module,<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><strong>Process.EnumerateModules()</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">frida_Module</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 返回一个模块列表</span><br>        <span class="hljs-keyword">var</span> process_Obj_Module_Arr = <span class="hljs-title class_">Process</span>.<span class="hljs-title function_">enumerateModules</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; process_Obj_Module_Arr.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(process_Obj_Module_Arr[i].<span class="hljs-property">path</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;hello&quot;</span>)!=-<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;模块名称:&quot;</span>,process_Obj_Module_Arr[i].<span class="hljs-property">name</span>);<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;模块地址:&quot;</span>,process_Obj_Module_Arr[i].<span class="hljs-property">base</span>);<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;大小:&quot;</span>,process_Obj_Module_Arr[i].<span class="hljs-property">size</span>);<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文件系统路径&quot;</span>,process_Obj_Module_Arr[i].<span class="hljs-property">path</span>);<br>            &#125;<br>         &#125;<br>    &#125;);<br>&#125;<br><span class="hljs-title function_">setImmediate</span>(frida_Module,<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><strong>enumerateImports()</strong></p><p>该API会枚举模块中所有中的所有Import函数，示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">frida_Module</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> hooks = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;libhello.so&#x27;</span>);<br>        <span class="hljs-keyword">var</span> <span class="hljs-title class_">Imports</span> = hooks.<span class="hljs-title function_">enumerateImports</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Imports</span>.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-comment">//函数类型</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;type:&quot;</span>,<span class="hljs-title class_">Imports</span>[i].<span class="hljs-property">type</span>);<br>            <span class="hljs-comment">//函数名称</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name:&quot;</span>,<span class="hljs-title class_">Imports</span>[i].<span class="hljs-property">name</span>);<br>            <span class="hljs-comment">//属于的模块</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;module:&quot;</span>,<span class="hljs-title class_">Imports</span>[i].<span class="hljs-property">module</span>);<br>            <span class="hljs-comment">//函数地址</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;address:&quot;</span>,<span class="hljs-title class_">Imports</span>[i].<span class="hljs-property">address</span>);<br>         &#125;<br>    &#125;);<br>&#125;<br><span class="hljs-title function_">setImmediate</span>(frida_Module,<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li></li></ol></li><li><p>Memory对象</p></li><li></li></ul></li><li><p><strong>frida实例操作</strong></p><ul><li><p>分析对象：AliCrackme_2.apk</p></li></ul><ol><li><p>首先，我们用apktool反编译apk文件，得到smali、xml等文件，从xml文件中发现apk的<code>activity</code>信息：</p></li><li><p>将apk文件导入jadx进行反编译，找到对应的<code>com.yaotong.MainActivity</code>文件</p><p>可以发现密码验证函数，那么我们只需要hook这个<code>securityCheck</code>函数就能进行绕过操作</p></li><li><p>我们编写hook.js脚本，hook<code>securityCheck</code>函数，修改属性，使无论输入什么都返回<code>True</code></p></li><li><p>下面运行apk，挂上hook.js，可以看到我们随机输入密码，都能显示密码正确</p></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>hook</tag>
      
      <tag>frida</tag>
      
      <tag>xposed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hook类型简介</title>
    <link href="/2022/09/02/hook%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/09/02/hook%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java层"><a href="#Java层" class="headerlink" title="Java层"></a>Java层</h1><h2 id="1、Dalvik-Hook"><a href="#1、Dalvik-Hook" class="headerlink" title="1、Dalvik Hook"></a>1、Dalvik Hook</h2><ul><li>环境：Android 5.0 以下</li><li>实现基础：Java反射机制、Dalvik虚拟机底层的Java方法、可修改进程空间的内存</li><li>实现：</li></ul><ol><li>因为Method结构体中的字段完整描述了一个Java方法，所以我们可以通过修改目标方法中相应字段的值，来达到Hook的目的</li><li>DDI框架：<strong>将一个你要hook的Dalvik层的函数</strong>,人为<strong>修改成一个你自己写的Native的函数</strong>。这样，<strong>当代码调用到这个函数</strong>的时候，实际上<strong>就变成调用你自己的JNI函数</strong>了，可以<strong>在你自己写的JNI函数中实现任何功能</strong></li></ol><h2 id="2、ART-Hook"><a href="#2、ART-Hook" class="headerlink" title="2、ART Hook"></a>2、ART Hook</h2><ul><li><p>环境：Android 5.0 以上</p></li><li><p>基本概念：ART中，每一个Java方法在虚拟机内部都由一个ArtMethod对象表示（native层，实际上是一个C++对象），这个native 的 ArtMethod对象包含了此Java方法的所有信息，比如名字，参数类型，方法本身代码的入口地址（entrypoint)等。</p></li><li><p>实现：<strong>入口点替换</strong></p><ol><li>把原方法对应的ArtMethod对象的entrypoint替换为目标方法的entrypoint，</li><li>使得原方法被调用过程中获取entrypoint时，拿到的是目标方法的entrypoint，</li><li>直接跳转到目标方法的code段，执行相应功能，达到Hook的目的。</li></ol></li><li><p>缺陷：若系统直接将要调用的ArtMethod的entrypoint写死在汇编代码里，这样方法调用的时候就不会先获取ArtMethod，也就不会去拿被替换的entrypoint，导致Hook失效。</p></li></ul><h1 id="Native层"><a href="#Native层" class="headerlink" title="Native层"></a>Native层</h1><h2 id="1、LD-PRELOAD-Hook"><a href="#1、LD-PRELOAD-Hook" class="headerlink" title="1、LD_PRELOAD Hook"></a>1、LD_PRELOAD Hook</h2><ul><li><p>概念：LD_PRELOAD是linux系统中的一个环境变量，<strong>它可以指定优先加载某个动态库</strong>。通过改变这个环境变量，我们可以指定要加载的动态链接库，在主程序和其动态链接库的中间加载别的动态链接库，覆盖正常的函数库。</p></li><li><p>实现：</p><p>示例程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* app.c */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-comment">// 验证注册码是否为ilikeandroid</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">checkSN</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* sn)</span> &#123;<br>    <span class="hljs-type">char</span> realcode[] = <span class="hljs-string">&quot;ilikeandroid&quot;</span>;<br>    <span class="hljs-keyword">return</span> !(<span class="hljs-built_in">strcmp</span>(realcode, sn));<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: app sn\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!checkSN(argv[<span class="hljs-number">1</span>])) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the sn was invalid!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thank you for your registration!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>编写新的libhook.so动态库，并在其中编写代码来hook目标函数，并编译生成新的动态库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*hook.c*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">getrealaddr</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">void</span>* lib = dlopen(<span class="hljs-string">&quot;libc.so&quot;</span>, RTLD_NOW | RTLD_GLOBAL);<br>    <span class="hljs-keyword">if</span> (lib == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;could not open file with dlopen() !!: %s\n&quot;</span>, dlerror());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">void</span>* symbol = dlsym(lib, <span class="hljs-string">&quot;strcmp&quot;</span>);<br>    <span class="hljs-comment">//fprintf(stdout, &quot;the real strcmp address: 0x%8x\n&quot;, symbol);</span><br>    dlclose(lib);<br>    <span class="hljs-keyword">return</span> symbol;<br>&#125;<br><br><span class="hljs-type">int</span> (*src_strcmp)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s1, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s2);<br><br><span class="hljs-comment">// 我们编写的新函数，使输入为123时，返回值为0，绕过原程序中的strcmp()检查</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">strcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s1, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s2)</span> &#123;<br>    <span class="hljs-comment">//fprintf(stdout, &quot;strcmp called. first arg is: %s, second arg is:%s\n&quot;, s1, s2);</span><br>    src_strcmp = (<span class="hljs-type">int</span> (*)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *))getrealaddr();<br>    <span class="hljs-comment">//若输入值为123，则返回值为0;</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-number">0</span> == src_strcmp(<span class="hljs-string">&quot;123&quot;</span>, s1)) || (<span class="hljs-number">0</span> == src_strcmp(<span class="hljs-string">&quot;123&quot;</span>, s2)))  &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> src_strcmp(s1, s2);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>再修改LD_PRELOAD环境变量的值为我们编写的新动态库路径，完成hook挂载</p></li></ol></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">adb push ./libhook.so /data/local/tmp/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">adb shell</span><br>root@:/ # cd /data/local/tmp<br>root@:/data/local/tmp # LD_PRELOAD=/data/local/tmp/libhook.so ./app 123<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">thank you for your registration!<br></code></pre></td></tr></table></figure><h2 id="2、GOT-Hook"><a href="#2、GOT-Hook" class="headerlink" title="2、GOT Hook"></a>2、GOT Hook</h2><ul><li><p>概念：GOT（全局偏移变量表），GOT Hook的一般思路是，修改内存中elf与so的符号指针，完成目标函数的hook</p><p>​PLT（程序链接表），</p></li><li><p>实现：</p></li></ul><ol><li><p>在.dynsym节中找到目标函数的区域，查看对应的反汇编代码（<code>.text节</code>）</p></li><li><p>writeText函数通过<code>BLX(相对寻址)指令</code>跳转到<code>.plt节</code>里，找到对应的fwrite@plt</p></li><li><p>在<code>.plt节</code>中计算得到fwrite的偏移地址为：0x2FE0，通过间接寻址跳转到<code>.got节</code>里</p></li><li><p>通过linux命令查找目标函数的基址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进程的虚拟地址空间</span><br>cat /proc/&lt;pid&gt;/maps<br></code></pre></td></tr></table></figure><p>得到目标函数所在so库的基址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">libnative-write.so库的基址为：0xD414F000<br></code></pre></td></tr></table></figure></li><li><p>所以，我们实际需要hook的函数<code>fwrite</code>的地址为：addr &#x3D; base_addr + 0x2FE0</p></li><li><p>接下来开始hook操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hook_simple.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;logger.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_START(addr) ((addr) &amp; PAGE_MASK)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_END(addr)   (PAGE_START(addr) + PAGE_SIZE)</span><br><br><span class="hljs-type">size_t</span> (*old_fwrite)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> count, FILE *fp);<br><br><span class="hljs-comment">// 我们编写的hook函数</span><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">hook_fwrite</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> count, FILE *fp)</span> &#123;<br>    LOG_D(<span class="hljs-string">&quot;hook fwrite success&quot;</span>);<br>    <span class="hljs-comment">//这里插入一段文本</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *text = <span class="hljs-string">&quot;hello &quot;</span>;<br>    old_fwrite(text, <span class="hljs-built_in">strlen</span>(text), <span class="hljs-number">1</span>, fp);<br>    <span class="hljs-keyword">return</span> old_fwrite(buf, size, count, fp);<br>&#125;<br><br><span class="hljs-comment">// 直接硬编码偏移地址的方式进行hook操作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Java_com_feature_hook_NativeHook_hookSimple</span><span class="hljs-params">(JNIEnv *env, jobject obj, jstring jSoName)</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *soName = (*env)-&gt;GetStringUTFChars(env, jSoName, <span class="hljs-number">0</span>);<br>    LOG_D(<span class="hljs-string">&quot;soName=%s&quot;</span>, soName);<br>    <span class="hljs-type">char</span> line[<span class="hljs-number">1024</span>] = <span class="hljs-string">&quot;\n&quot;</span>;<br>    FILE *fp = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">uintptr_t</span> base_addr = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uintptr_t</span> addr = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 1. 查找自身对应的基址</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == (fp = fopen(<span class="hljs-string">&quot;/proc/self/maps&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>))) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">while</span> (fgets(line, <span class="hljs-keyword">sizeof</span>(line), fp)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != <span class="hljs-built_in">strstr</span>(line, soName) &amp;&amp;<br>            <span class="hljs-built_in">sscanf</span>(line, <span class="hljs-string">&quot;%&quot;</span>PRIxPTR<span class="hljs-string">&quot;-%*lx %*4s 00000000&quot;</span>, &amp;base_addr) == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    fclose(fp);<br>    LOG_D(<span class="hljs-string">&quot;base_addr=0x%08X&quot;</span>, base_addr);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == base_addr) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//2. 基址+偏移=真实的地址</span><br>    addr = base_addr + <span class="hljs-number">0x2FE0</span>;    <span class="hljs-comment">//硬编码目标函数的真实地址</span><br>    LOG_D(<span class="hljs-string">&quot;addr=0x%08X&quot;</span>, addr);<br>    <span class="hljs-comment">//注意：调整写权限</span><br>    mprotect((<span class="hljs-type">void</span> *) PAGE_START(addr), PAGE_SIZE, PROT_READ | PROT_WRITE);<br><span class="hljs-comment">//保存旧的函数地址</span><br>old_fwrite = *(<span class="hljs-type">void</span> **) addr;<br>    <span class="hljs-comment">//替换新的目标地址，挂hook</span><br>    *(<span class="hljs-type">void</span> **) addr = hook_fwrite;<br>    <span class="hljs-comment">//注意：清除指令缓存</span><br>    __builtin___clear_cache((<span class="hljs-type">void</span> *) PAGE_START(addr), (<span class="hljs-type">void</span> *) PAGE_END(addr));<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="3、Inline-Hook"><a href="#3、Inline-Hook" class="headerlink" title="3、Inline Hook"></a>3、Inline Hook</h2><ul><li><p>概念：Inline Hook即内部跳转Hook，通过替换原函数汇编代码开始的指令为跳转指令，使原函数跳转到自己的函数</p><p>通常会保留原函数的调用接口</p></li><li><p>原理：</p></li><li><p>实现：</p></li></ul><ol><li><p>判断当前函数为ARM指令还是Thumb指令</p><ul><li><p>ARM指令：4字节对齐，每条指令长度均为32位</p></li><li><p>Thumb指令：2字节对齐，Thumb16指令长度为16位，Thumb32指令长度为32位</p></li></ul></li><li><p>使用<code>mprotect()</code>将目标函数属性改为可写，保存目标函数起始处指令（inline hook跳转指令长度）和寄存器状态</p></li><li><p>将目标函数起始处的指令用构造好的跳转指令替换，去执行我们编写的hook函数</p></li><li><p>在hook函数中，我们先保存当前全部的寄存器状态到栈中。然后用BLX命令（以arm模式）跳转去执行用户自定义的Hook后的新功能函数。</p></li><li><p>新功能函数执行完成后，从栈恢复所有的寄存器状态。最后（以arm模式）跳转至第三部分备份代码处。</p></li><li><p>备份代码中，我们先执行之前备份的2条指令，然后用LDR指令跳转回Hook地址+8bytes的地址处继续执行。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hook</tag>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Smali基础</title>
    <link href="/2022/09/02/Smali%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/09/02/Smali%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Smali"><a href="#Smali" class="headerlink" title="Smali"></a>Smali</h1><h2 id="1-smali文件结构"><a href="#1-smali文件结构" class="headerlink" title="1. smali文件结构"></a>1. smali文件结构</h2><ul><li><p>我们一般使用apktool来反编译<code>apk/dex</code>文件，每个内部类反编译时，会单独生成一个smali文件。</p><p><code>MainActivity$1.smali</code>，像这样文件名中包含<code>$</code>符号的smali文件，就是内部类的smali文件</p></li><li><p>smali内容格式：</p><ul><li><code>.class</code>类的完整签名</li><li><code>.super</code>父类类名</li><li><code>.source</code>源文件名</li><li><code>.field</code>字段列表</li><li><code>.implements</code>实现的接口</li><li><code>.annotation</code>注解列表</li><li><code>.method</code>方法列表</li></ul></li></ul><h2 id="2-smali语法"><a href="#2-smali语法" class="headerlink" title="2.smali语法"></a>2.smali语法</h2><ul><li><p>数据类型：</p><ul><li><table><thead><tr><th align="center">Java</th><th align="center">Smali</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">V</td></tr><tr><td align="center">boolean</td><td align="center">Z</td></tr><tr><td align="center">byte</td><td align="center">B</td></tr><tr><td align="center">short</td><td align="center">S</td></tr><tr><td align="center">char</td><td align="center">C</td></tr><tr><td align="center">int</td><td align="center">I</td></tr><tr><td align="center">long</td><td align="center">J</td></tr><tr><td align="center">float</td><td align="center">F</td></tr><tr><td align="center">double</td><td align="center">D</td></tr></tbody></table></li><li><p>数组：</p><ol><li>在类型前面加[来表示该类型的数组，例如<code>[I</code>表示<code>int[]</code>，<code>[Ljava/lang/String</code>表示<code>String[]</code></li><li>表示多维数组，只需要增加<code>[</code>的数量，例如<code>[[I</code>表示二维数组<code>int[][]</code></li></ol></li><li><p>引用类型：</p><p>在Smali中都是用<code>L包名路径/类名</code>表示，</p><p>例如Android中的TextView类，它的包名是 **<code>android.widget</code>**，在Smali中表示这个类，就要写成 <strong><code>Landroid/widget/TextView</code></strong></p></li><li><p>函数定义：</p><p>格式：<code>Func-Name (Para-Type1Para-Type2Para-Type3...)Return-Type</code></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// smali语句</span><br><span class="hljs-keyword">void</span> foo() --------&gt; foo ()V<br><span class="hljs-keyword">boolean</span> foo(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>) -----------&gt; foo (III)Z<br>String foo (<span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">int</span>[], <span class="hljs-keyword">int</span>[], String, <span class="hljs-keyword">long</span>) --------&gt; foo (Z[I[ILjava<span class="hljs-regexp">/lang/</span>String;J)Ljava<span class="hljs-regexp">/lang/</span>String<br></code></pre></td></tr></table></figure></li></ul></li><li><p>方法：</p><ul><li><p>语法：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">.method 描述符 方法名(参数类型)返回类型<br>  ``方法代码...<br>.end <span class="hljs-keyword">method</span><br></code></pre></td></tr></table></figure><p>参数类型可以有<strong>0个或多个</strong>，<strong>返回类型必须是一个</strong></p><p><code>.locals</code>：声明当前方法中使用的寄存器数量</p><p><code>.param</code>：指定方法中的参数名</p><p><code>.prologue</code>：声明接下来的内容为DEX指令</p><p><code>.line</code>：方法在Java代码中的行号信息</p></li><li><p>调用：</p><p><code>invoke-xxxxxx &#123;参数列表&#125;, 类名-&gt;方法名(参数类型)返回类型</code></p><table><thead><tr><th align="center">指令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">invoke-virtual</td><td align="center">调用虚方法</td></tr><tr><td align="center">invoke-direct</td><td align="center">直接调用方法</td></tr><tr><td align="center">invoke-static</td><td align="center">调用静态方法</td></tr><tr><td align="center">invoke-super</td><td align="center">调用父类方法</td></tr><tr><td align="center">invoke-interface</td><td align="center">调用接口方法</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java代码</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br>obj.equals(<span class="hljs-string">&quot;456&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">// smali语句<br>invoke-virtual &#123;v0, v1&#125;, Ljava/lang/Object;-&gt;equals(Ljava/lang/Object;)Z<br></code></pre></td></tr></table></figure><p><strong>invoke-xxxxx&#x2F;range</strong>：当调用方法的参数多于5个时（含5个），不能直接使用以上的指令，需要在后面加上<code>/range</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> Smali语句<br>invoke-direct<span class="hljs-regexp">/range&#123;v0..v5&#125;, Lcom/</span>pb<span class="hljs-regexp">/ui/</span>TestActivity;-&gt; h(ILjava<span class="hljs-regexp">/lang/</span>String, Ljava<span class="hljs-regexp">/lang/</span>String;Landroid<span class="hljs-regexp">/content/i</span>ntent;I)Z<br></code></pre></td></tr></table></figure></li><li><p>返回值</p><p>Smali中需要分开来表示调用函数和返回函数结果，</p><p>如果调用的函数返回非void, 还需要move-result(返回基本数据类型)和move-result-object(返回对象)指令:</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">// smali语句<span class="hljs-built_in"></span><br><span class="hljs-built_in">const-string </span>v0,<span class="hljs-string">&quot;Eric&quot;</span><br>invoke-static&#123;v0&#125;,<span class="hljs-class">Lcom/pbi;</span>-&gt;t(<span class="hljs-class">Ljava/lang/String;</span>)<span class="hljs-class">Ljava/lang/String;</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">move-result-object </span>v2;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>字段：</p><ul><li><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// .field 描述符 字段名:字段类型</span><br><span class="hljs-comment">// java代码</span><br><span class="hljs-keyword">public</span> String text;<br><span class="hljs-comment">// smali语句</span><br>.field <span class="hljs-keyword">public</span> text:Ljava/lang/String;<br></code></pre></td></tr></table></figure></li><li><p>引用字段：</p><p><strong><code>类名-&gt;字段名:字段类名</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java代码</span><br>System.out.println(<span class="hljs-string">&quot;Hello world&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">// smali语句，调用 println 方法前需要现将 System 类的字段 out 放到寄存器 v0 中<span class="hljs-built_in"></span><br><span class="hljs-built_in">sget-object </span>v0, <span class="hljs-class">Ljava/lang/System;</span>-&gt;out:<span class="hljs-class">Ljava/io/PrintStream;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>寄存器：</p><p>在Smali中，不能直接把字符串参数传递给方法。需要一个寄存器（比如v0），先把”Hello”放到v0中，然后再调用abc方法</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali"><span class="hljs-comment"># 定义一个字符串常量&quot;Hello&quot;放到v0中</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">const-string </span>v0, <span class="hljs-string">&quot;Hello&quot;</span><br><span class="hljs-comment"># 调用abc方法，需要的参数放在v0中</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">invoke-static </span>&#123;v0&#125;, <span class="hljs-class">LXX;</span>-&gt;abc(<span class="hljs-class">Ljava/lang/String;</span>)V<br></code></pre></td></tr></table></figure><p><strong>参数寄存器</strong>：Smali还特意定义了一种参数寄存器pN，用于存放这个方法传入的参数的值。</p><p>如果一个方法有n个寄存器，有m个参数，那么n必须大于等于m，并且n个寄存器的后面m个是参数寄存器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Java代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br> <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> i)</span>&#123;<br>        System.out.println(s);<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs smali">// test1()函数的Smali语句<br><span class="hljs-keyword">.method</span><span class="hljs-keyword"> static</span> test1(<span class="hljs-class">Ljava/lang/String;</span>I)V<br><span class="hljs-keyword">    .registers</span> 3<br> <br><span class="hljs-keyword">    .prologue</span><br><span class="hljs-keyword">    .line</span> 4<br>   <span class="hljs-built_in"> sget-object </span>v0, <span class="hljs-class">Ljava/lang/System;</span>-&gt;out:<span class="hljs-class">Ljava/io/PrintStream;</span><br> <br>   <span class="hljs-built_in"> invoke-virtual </span>&#123;v0, p0&#125;, <span class="hljs-class">Ljava/io/PrintStream;</span>-&gt;println(<span class="hljs-class">Ljava/lang/String;</span>)V<br> <br><span class="hljs-keyword">    .line</span> 5<br>   <span class="hljs-built_in"> sget-object </span>v0, <span class="hljs-class">Ljava/lang/System;</span>-&gt;out:<span class="hljs-class">Ljava/io/PrintStream;</span><br> <br>   <span class="hljs-built_in"> invoke-virtual </span>&#123;v0, p1&#125;, <span class="hljs-class">Ljava/io/PrintStream;</span>-&gt;println(I)V<br> <br><span class="hljs-keyword">    .line</span> 6<br>   <span class="hljs-built_in"> return-void</span><br><span class="hljs-built_in"></span><span class="hljs-keyword">.end method</span><br></code></pre></td></tr></table></figure></li><li><p>函数实体</p><ul><li><p>if判断</p><p>格式：<code>if-[test] v1,v2, [condition]</code></p><p>其中[condition]为符合判断结果后的跳转条件，需要提前定义好。判断操作也通常和goto配合使用，用来实现循环或者if-else语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java代码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        String result;<br>        <span class="hljs-keyword">if</span> (a &gt; b) &#123;<br>            result = <span class="hljs-string">&quot;a great than b&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result = <span class="hljs-string">&quot;a less than or equals b&quot;</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>对应的Smali代码如下，在Java中编写的if语句，往往在对应的Smali中，会变成相反的判断逻辑：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs smali"><span class="hljs-keyword">.method</span><span class="hljs-keyword"> private</span> test()V<br><span class="hljs-keyword">    .registers</span> 4<br><br><span class="hljs-keyword">    .line</span> 24<br>   <span class="hljs-built_in"> const/4 </span>v0, 0x0<br><br><span class="hljs-keyword">    .line</span> 25<br><span class="hljs-keyword">    .local</span> v0, <span class="hljs-string">&quot;a&quot;</span>:I<br>   <span class="hljs-built_in"> const/4 </span>v1, 0x1<br><br><span class="hljs-keyword">    .line</span> 27<br><span class="hljs-keyword">    .local</span> v1, <span class="hljs-string">&quot;b&quot;</span>:I<br>    // 判断a&lt;=b，成立则跳转到cond_7，否则a&gt;b继续执行<br>   <span class="hljs-built_in"> if-le </span>v0, v1,<span class="hljs-keyword"> :cond_7</span><br><br><span class="hljs-keyword">    .line</span> 28<br>   <span class="hljs-built_in"> const-string </span>v2, <span class="hljs-string">&quot;a great than b&quot;</span><br><br><span class="hljs-keyword">    .line</span> 28<br><span class="hljs-keyword">    .local</span> v2, <span class="hljs-string">&quot;result&quot;</span>:<span class="hljs-class">Ljava/lang/String;</span><br>    // 使用goto来防止跳转至cond_7，等同于else分支<br>   <span class="hljs-built_in"> goto </span>:goto_9<br><br><span class="hljs-keyword">    .line</span> 30<span class="hljs-keyword"></span><br><span class="hljs-keyword">    .end local</span> v2    <span class="hljs-comment"># &quot;result&quot;:Ljava/lang/String;</span><br>   <span class="hljs-keyword"> :cond_7</span><br>   <span class="hljs-built_in"> const-string </span>v2, <span class="hljs-string">&quot;a less than or equals b&quot;</span><br><br><span class="hljs-keyword">    .line</span> 32<br><span class="hljs-keyword">    .restart</span> local v2    <span class="hljs-comment"># &quot;result&quot;:Ljava/lang/String;</span><br>   <span class="hljs-keyword"> :goto_9</span><br>   <span class="hljs-built_in"> return-void</span><br><span class="hljs-built_in"></span><span class="hljs-keyword">.end method</span><br></code></pre></td></tr></table></figure></li><li><p>for</p><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">10</span>;i++)｛｝<br></code></pre></td></tr></table></figure><p>smali代码：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs smali">//<span class="hljs-built_in"> int </span>i=0<span class="hljs-built_in"></span><br><span class="hljs-built_in">const/4 </span>v0, 0x0<span class="hljs-keyword"></span><br><span class="hljs-keyword">:goto_1</span><br>// 10<span class="hljs-built_in"></span><br><span class="hljs-built_in">const/16 </span>v1, 0xa<br>//<span class="hljs-built_in"> if </span>i&gt;=10<span class="hljs-built_in"></span><br><span class="hljs-built_in">if-ge </span>v0, v1,<span class="hljs-keyword"> :cond_8</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">add-int/lit8 </span>v0, v0, 0x1<br>// 继续循环<span class="hljs-built_in"></span><br><span class="hljs-built_in">goto </span>:goto_1<br>// 退出循环<span class="hljs-keyword"></span><br><span class="hljs-keyword">:cond_8</span><br>return-void<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-smali实例操作"><a href="#3-smali实例操作" class="headerlink" title="3.smali实例操作"></a>3.smali实例操作</h2><p><strong>绕过app签名验证机制</strong></p><ol><li><p>以书旗app为分析样本，shuqi.apk。已知该app存在签名验证机制</p></li><li><p>首先使用apktool对样本apk反编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">apktool d -f shuqi.apk -only-main-classes  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">正常apktool d ***.apk就可以但是书旗的会提示，非法Dex，这是因为apk里有加密过后的dex文件，比如有些apk的assets目录下有加密后的Dex文件，添加–only-main-classes参数</span><br></code></pre></td></tr></table></figure><p>反编译生成以下文件：</p></li><li><p>按照正常的程序我们现在就可以修改反编译后的代码，然后打包、重新签名，再次进行安装。</p><p>但是该app有签名验证，签名验证能防止进行二次打包，会将打包后前签名和代码中的进行比对，如果签名不对将启动失败。</p></li><li><p>然后，将shuqi.apk载入jadx进行反汇编，找到入口</p><p>直接搜索包含<code>Application</code>字段的类，一般混淆也不会混淆这个入口</p></li><li><p>跟进到<code>com.shuqi.app.ShuqiApplication</code>中</p><p>发现前面验证函数<code>checkSigAsync()</code></p></li><li><p>继续跟进到<code>checkSigAsync()</code>中</p><p>红框中就是签名验证的相关操作。我们绕过验证一般有两种方式：</p><p>一种是修改java代码重新编译，但是会因为开发的环境的差异导致最后运行失败，</p><p>另一种，就是直接修改smali文件，然后二次打包build生成新的apk</p></li><li><p>下面我们回到smali文件中分析，由上面的分析知道要分析的smali文件在<code>shuqi/smali/com/shuqi/app/</code>路径下</p><p>打开<code>ShuqiApplication.smali</code></p><ul><li><p>找到<code>checkSigAsync()</code>方法：</p></li><li><p>跟进到smali中调用该函数，在166行</p></li></ul></li><li><p>简单的绕过验证函数，直接删除该调用，再启动app后就不会进行签名验证了。</p></li><li><p>修改smali文件后，我们重新用apktool进行编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apktool b ./shuqi-decompiled  # 对shuqi目录进行打包<br></code></pre></td></tr></table></figure></li><li><p>最后，生成自己的签名信息，然后修改后重打包的apk就能正常安装运行了。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Smali</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
